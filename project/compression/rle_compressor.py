# у цьому коді проходить як на мене найголовніша функція це стиснення та роспаковка данних із строки за формулою rle
# формулу rle я знайшов за посиланням https://ru.stackoverflow.com/questions/595126/base-rle-encode-python
from .compressor_interface import compressor # імпорт класу завдяки якому буде проходити алгортим стиснення і розпакування рядка

class rle_compressor(compressor):
    # клас для реалізації алгоритму rle

    def compress(self, data: str) -> str: # метод приймає на вихіт строку data 
        # стиснення рядку і до цього я ще додав обробку що якщо символ лише 1 то ми його не підписуємо бо дуже багато байтів тоді показує і по розмірам іноді навіть файл стиснений з оргіналом ставав ідентичним
        compressed = [] # порожній список куди потім буде записанно результат стиснення
        i = 0 # індекс для проходження через рядок
        while i < len(data): # цикля який проходить через кожне слово
            count = 1 # змінна встановлюється на 1 щоб одиничні букви пропускало і записувало в подальшому тілько повторюючі букви
            while i + 1 < len(data) and data[i] == data[i + 1]: # цикл який підраховує однакову кількість символів і коли кожен символ такий сами то змінюється count і (i це на англ він написаний)
                i += 1
                count += 1
            if count > 1: # тут якщо count букви більше за 1 то буде писатись буква 1 (підписується як data) і потім count який зміненний на кількість таких самих букв
                compressed.append(f"{data[i]}{count}")
            else:
                compressed.append(data[i]) # якщо такого не проізошло то просто буде буква і без ніякої цифри 1
            i += 1 # індекс у нас збільшується на один щоб перейти далі
        return ''.join(compressed) # метод повертає стиснутий рядок

    def decompress(self, data: str) -> str: # приймає на вихід стиснений рядок data і повертає оригінальний рядок після роспакування
        # розпоковування рядка
        decompressed = [] # порожній список
        i = 0 # індекс і
        while i < len(data):
            char = data[i] # цикл інтерації рядку де змінна char зберігає так сказати поточний символ
            if i + 1 < len(data) and data[i + 1].isdigit(): # якщо після букви іде цифра то треба написати цю цифру стільки разів скільки цифра
                count = int(data[i + 1]) # отримання кількості повторення
                decompressed.append(char * count) # потім цей символ додається до списку стільки разів скільки вказано в count
                i += 2 # ми перескакуємо через символ і цифру (це я зробив для того щоб розмір файлу був трішки меншим)
            else:
                decompressed.append(char) # якщо після символу немає цифри то просто додаємо до списку
                i += 1 # і перескакуємо на інший символ
        return ''.join(decompressed) # повернення роспакованого рядку